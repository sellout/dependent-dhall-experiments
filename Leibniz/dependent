{- Leibniz equality forms a groupoid, with
 ‚Ä¢ unit = reflexivity,
 ‚Ä¢ product = transitivity, and
 ‚Ä¢ inverse = symmetry.

   FIXME: The implementation of `inverse` forces the target of the functor to be
          the enriching category. I don‚Äôt know if this is fundamentally
          required, or just a consequence of the common formulations being where
          everything is ùêíùêûùê≠.
-}
let vObject = Type

in    Œª(cObject : Type)
    ‚Üí let dObject = vObject
      
      let Leibniz =
            { arrow =
                  Œª(a : { _1 : cObject, _2 : cObject })
                ‚Üí ‚àÄ(f : cObject ‚Üí dObject) ‚Üí f a._1 ‚Üí f a._2
            }
      
      let refl = Œª(a : cObject) ‚Üí Œª(f : cObject ‚Üí dObject) ‚Üí Œª(x : f a) ‚Üí x
      
      let trans =
              Œª(a : { _1 : cObject, _2 : cObject })
            ‚Üí Œª ( p
                :   ‚àÄ(r : Type)
                  ‚Üí (   ‚àÄ(z : cObject)
                      ‚Üí Leibniz.arrow { _1 = z, _2 = a._2 }
                      ‚Üí Leibniz.arrow { _1 = a._1, _2 = z }
                      ‚Üí r
                    )
                  ‚Üí r
                )
            ‚Üí Œª(f : cObject ‚Üí dObject)
            ‚Üí Œª(x : f a._1)
            ‚Üí p
              (f a._2)
              (   Œª(z : cObject)
                ‚Üí Œª(g : Leibniz.arrow { _1 = z, _2 = a._2 })
                ‚Üí Œª(h : Leibniz.arrow { _1 = a._1, _2 = z })
                ‚Üí g f (h f x)
              )
      
      in  { unit =
              refl
          , product =
              trans
          , hom =
              { map =
                    Œª(a : { _1 : cObject, _2 : cObject })
                  ‚Üí Œª(b : { _1 : cObject, _2 : cObject })
                  ‚Üí Œª ( f
                      : { _1 :
                            Leibniz.arrow { _1 = b._1, _2 = a._1 }
                        , _2 :
                            Leibniz.arrow { _1 = a._2, _2 = b._2 }
                        }
                      )
                  ‚Üí Œª(fn : Leibniz.arrow a)
                  ‚Üí trans
                    { _1 = b._1, _2 = b._2 }
                    (   Œª(r : Type)
                      ‚Üí Œª ( arrowsOut
                          :   ‚àÄ(z : cObject)
                            ‚Üí Leibniz.arrow { _1 = z, _2 = b._2 }
                            ‚Üí Leibniz.arrow { _1 = b._1, _2 = z }
                            ‚Üí r
                          )
                      ‚Üí arrowsOut
                        a._1
                        ( trans
                          { _1 = a._1, _2 = b._2 }
                          (   Œª(r : Type)
                            ‚Üí Œª ( arrowsOut
                                :   ‚àÄ(z : cObject)
                                  ‚Üí Leibniz.arrow { _1 = z, _2 = b._2 }
                                  ‚Üí Leibniz.arrow { _1 = a._1, _2 = z }
                                  ‚Üí r
                                )
                            ‚Üí arrowsOut a._2 f._2 fn
                          )
                        )
                        f._1
                    )
              }
          , inverse =
                Œª(a : { _1 : cObject, _2 : cObject })
              ‚Üí Œª(subst : Leibniz.arrow a)
              ‚Üí subst
                (Œª(x : cObject) ‚Üí Leibniz.arrow { _1 = x, _2 = a._1 })
                (refl a._1)
          }
